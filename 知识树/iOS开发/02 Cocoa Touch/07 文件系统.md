## 文件系统

* 沙盒
	* UserDefault
	* 归档 NSKeyedArchiver
	* SQL3
	* CoreData
* KeyChain

### CoreData和SQLite

CoreData:

1. 可视化，且具有undo/redo能力
2. 可以实现多种文件格式

SQL:

1. 基于C，需要使用SQL语句
2. 大量数据的表关系更加直观
3. 写入性能比直接写文件要高；读取性能和数据大小有关，小于20k时写文件速度更快；

#### 沙盒

* Document: 存储重要数据，itunes同步应用会备份；
	* Document/Inbox: 用来存放由外部应用请求当前应用程序打开的文件，会被同步备份；
* Library/Caches: 体积大，不需要备份的非重要信息，系统不删除，不会同步备份；
* Library/Preferences: 设置信息，会被同步备份；
* tmp: 临时文件，系统会在应用没在运行的时候删除该目录下文件，不会同步备份；

#### UD

储存在`Library/Preferences`，自定义数据不能直接存储；

储存数据没有被加密，iOS6以前直接可见，iOS6以后破解可见；

#### 归档 NSKeyedArchiver

需要实现`NSCoding`或者`NSSecureCoding`，会把对象转换为`NSData`，再通过文件存储的方法保存在指定位置；

#### KeyChain

能够在卸载程序之后依然保存在当前设备里的方法，本身是一个加密后的数据库；

可以设置`KeyChain Groups`来保证同一公司的app访问共有数据；

但是安全考虑，在`KeyChain`中保存的信息也需要加密；

## 缓存系统

### NSCache

对于需要频繁读取的数据，可以用`NSCache`把数据存到内存中提高读取性能;默认有效期为一周；

三方库中`AFNetworking`和`SDWebImage`都有使用`NSCache`保存数据；

#### 相比于直接使用`NSMutableDictionary`的优势

* `NSCache`是线程安全的，多线程中不需要额外加锁；

* 接口类似于`NSMutableDictionary`,在收到系统内存警告时会主动调用`removeAllObject`清除数据；

* `NSCache`的`Key`不会被复制，可以不需要实现`NSCopying`协议；

#### 缓存删除机制

`NSCache`声明的唯一代理方法是一个对象即将被删除，触发时机有

* `NSCache`缓存对象自身被释放
* 手动调用了`removeObjectForKey:`或者`removeAllObjects` 方法
* 缓存中对象的个数大于`countLimit`，或者对象的总`cost`值大于`totalCostLimit`
* 程序进入后台
* 收到系统内存警告

#### 实际案例 SDWebImage

需要关注的点

* 源码中标识的图片有效时间默认为1周


### NSURLCache

是系统的缓存机制，为应用的`URL请求`提供了内存以及磁盘上的综合缓存机制；默认提供10MB的磁盘空间和512kb的内存空间；

任何通过`NSURLConnection`和`NSURLSession`加载的请求都会被`NSURLCache`处理；

对应都存在`willCacheResponse`的代理方法，可以在方法中处理response，修改服务器设定的缓存策略；

本质是基于`SQLite`实现的，沙盒中会出现对应的sql文件；

--

## 磁盘硬件读写

cache是高速缓存，用于CPU和内存之间的缓冲；buffer是I/O缓存，用于内存和硬盘(硬件)的缓冲；cache是加速读，buffer是缓冲写； 

### inode

硬盘的最小存储单位是“扇区(Sector)”，每个扇区存储0.5kb。操作系统读取硬盘的时候会一次读取多个扇区即读取一个“块(block)”，块的大小最常见的是4kb。

其中储存文件的元信息的(例如文件的创建者，创建日期，文件的大小等)区域叫做inode，索引节点。

* 文件的字节数
* 文件拥有着的User ID
* 文件的Group ID
* 文件的读、写、执行权限
* 文件的时间戳(ctime:inode上一次变动的时间,mtime:文件内容上一次变动的时间,atime:文件上一次打开的时间)
* 链接数，有多少文件名指向这个inode
* 文件数据block位置

Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。
表面上用户通过文件名打开了文件，实际上系统内部这个过程分成了3步；

1. 找到这个文件名对应的inode号码
2. 通过inode号码获取inode信息
3. 根据inode信息找到文件所在block，读出数据

#### 硬链接 

一般情况，文件名和inode号码是“一一对应”关系，每个inode号码对应一个文件名。但是Unix/Linux系统允许多个文件名指向同一个inode号码。

这意味着，可以用不同的文件名访问同样的内容；对文件内容修改会影响所有文件名；但是删除一个文件名，不影响另一个文件名的访问，这种情况称为“硬链接(hard link)”。

#### 软链接

文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此无论操作哪一个文件，最终读取的都是文件B，这时文件A就称为文件B的“软链接(soft link)”或者“符号链接(symbolic link)”。

#### 正常的文件读写过程

1. 进程调用库函数向内核发起读文件请求
2. 内核通过检查进程的文件描述符定位到虚拟文件系统已打开文件列表表项
3. 调用该文件可用的系统调用函数read()
4. read()函数通过文件表项 链接到目录项模块，根据传入的路径，在目录项模块中检索，找到该文件的inode
5. 在inode中，通过文件内容偏移量计算出要读取的页
6. 通过inode找到文件对应的address_space
7. 在address_space中访问改文件的页缓存树，查找对应的页缓存结点
	1. 如果页缓存命中直接返回文件内容
	2. 如果页缓存缺失，产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第7步查找页缓存
8. 文件读取完成

写文件前6步和读文件一致，查询address_space中查询对应页缓存是否存在；

1. 如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了，这个时候文件修改还位于页缓存，没有写回到磁盘中；
2. 如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，通过inode找到改文件的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第1步；
3. 一个页缓存中的页如果被修改，那么会被标记为脏页，脏页需要写回到磁盘中的文件块:
	1. 手动调用sync()或者fsync()系统调用，把脏页写回
	2. pdflush进程会定时把脏页写回磁盘

	
### mmap

适合场景

* 很大的文件，需要随机访问一个或者多个；(大文件最好只映射文件的小部分，大文件会消耗活动内存)
* 很小的文件，想要读入内存并且经常访问；尤其是不超过几个内存页的文件(单个内存页通常为4KB)；
* 需要在内存中缓存文件的特定部分；文件映射消除了缓存数据的需要，使得系统磁盘缓存中的其他数据空间更大；

不适合的场景

* 期望从开始到结束的顺序读取一个文件
* 文件本身有几百兆字节或者更大，那么会快速填充内存，并可能导致内存分页；对于大型顺序读取文件，禁用磁盘缓存并将文件读入小内存缓冲区；
* 如果文件大于可用的连续虚拟内存地址空间，对于64位应用程序来说不是什么问题，但是对于32位应用程序来说，会有问题；
* 该文件在可移动驱动器上
* 改文件在网络驱动器上

```
常规文件操作需要通过磁盘、页缓存、用户空间执行两次数据拷贝。
而mmap操控文件，只需要从磁盘到用户空间，只会执行一次数据拷贝。
```