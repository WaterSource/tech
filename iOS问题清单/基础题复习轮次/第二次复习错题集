第二次复习错题集
3.
oc的内存管理是用引用计数实现的
mrc需要手动添加retain、release、autorelease等方法
arc会在编译期自动添加方法
对连续的+1-1惊醒了优化
对函数返回的对象，如果外部马上retain的情况，会跳过函数内的autorelease和retain

-7.
在对象最后一次release之后调用dealloc方法
方法返回之后自动调用父类的dealloc
在根类
清除关联对象
清空引用计数表，弱引用表
将weak引用置nil

16.
block是封装了函数和其上下文的oc对象
根据存储的控件不同有3种类别，全局、栈、堆，都继承自NSBlock

-17.
因为函数作用域的问题，需要跨函数访问所以捕获了局部变量
临时变量会自动添加auto关键字，值引用的方式传递到block中
有static关键字修饰的静态临时变量会指针传递到block中
全局变量不被捕获，可以直接在block中访问

18.
arc在以下场景会自动调用copy
作为函数返回值时
被强引用时
cocoa api 方法作为参数时
gcd 方法作为参数时

-22.
valuewillchange
valuedidchange

27.
category实现的属性、方法都在category_t结构体中，在调用时动态拷贝的类对象中；
声明的属性不会自动合成，没有ivar，setter和getter

28.
类对象的属性列表在编译期已经决定，分类的属性不会自动合成
分类是在运行时才添加到对象的结构体
类对象在编译期就决定了实例属性表

-30.
load方法在程序启动时调用，每个类文件都会按照 父类-子类-分类 的顺序逐个调用
子类没有实现load方法时，不会触发调用；

initialize方法在第一次调用该类方法是调用
子类方法调用的时候，父类的方法也会被调用 父类实现调用结束会调用子类实现
分类有实现会覆盖子类实现，子类有实现会覆盖父类实现
子类没有实现时，会调用父类实现

31.
加载可执行文件
加载动态库，进行符号绑定
objc初始化，注册类、分类，检查seletor的唯一性
load方法，初始化全局静态变量，调用指定前缀修饰的方法
appdelegate didfinishlaunchwithoption