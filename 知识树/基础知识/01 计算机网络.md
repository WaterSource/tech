[TOC]

## 计算机网络

### 概念

#### 计算机网络

将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。

#### 网络协议

一个协议定义了两个或者多个通信实体之间交换数据的报文格式和次序，以及报文发送或接受一条报文或其他事件所采取的动作。

在各种网络应用中，端系统(c/s,p2p)彼此交换报文。

#### 网络分层

网络设计者以分层的方式组织协议以及实现这些协议的网络硬件和软件。每个协议都属于某一个层次，每一个层次都向上提供服务。

各层所有协议被称为协议栈。

##### 根据Internet协议栈(一般来说就是TCP/IP网络)

* 应用层
* 传输层
* 网络层
* 链路层
* 物理层

##### OSI模型(Open System Interconnect开放式系统互联)

* 应用层
* 表示层
* 会话层
* 传输层
* 网络层
* 链路层
* 物理层

##### TCP/IP模型

* 应用层
* 传输层
* 网络层(IP层)
* 网际接口层

#### 网络层

主要实现将分组报文传输到目的地址，精确到网络接口(port to port)，并不精确到应用程序。

路由器也工作在这一层，网络层最重要的两个功能就是转发和路由器选择。

##### IP协议

能在源地址和目的地址之间传送数据包(packet)，为了适应不同网络对包大小的要求，允许对数据大小的重新组装功能。

* 不可靠，IP协议只能尽力而为提供最好的传输服务，不能保证数据包能成功抵达目的地。
* 无连接，IP协议不维护关于后续数据包的状态信息，每一个数据包都单独处理。

#### 传输层 TCP UDP

TCP/UDP,IP 这些协议都有的共同功能，即寻址。IP协议将数据包从主机传输到主机，TCP/UDP则使用端口号，把数据包下发到应用程序。

##### 多路复用 与 多路分解

一台设备可能同时有多个进程在网络交换数据，一个数据段到了传输层之后，需要被定向到对应的套接字中。

在接收端，将传输层报文段定向到适当的套接字的工作称为多路分解。

在发送端，从不同套接字中收集数据块，并为每个数据块封装上对应的头部信息从而生成报文段，然后将报文段传递到网络层的工作称为多路复用。

#### TCP

TCP的可靠性，无差错、不丢失、不重复、有序性

* 校验和
	* 用于检测在一个传输分组中的比特错误
* 定时器
	* 用户超时/重传一个分组
* 序号
	* 用于为从发送方流向接收方的数据分组按顺序编号，保证接收数据有效性及检测出冗余副本
* 确认 ack
	* 接收方告诉发送方一个分组或一组分组已被正确接收。确认报文通常携带着被确认的分组或者多个分组序号
* 否定确认
	* 接收方告诉发送方某个分组未被正确接收
* 窗口、流水线
	* 用于增加信道的吞吐量

##### 最大报文长度
##### 消息确认
##### 差错控制

发送端具有一个存储报文段的缓冲区(buffer)称为发送端窗口，用于存放已经发送但是尚未接收到确认的报文段。如果接收到确认，会将相应的报文段从发送端窗口移除。如果在一段时限没有收到确认，会认为报文段发送失败，此时发送端会从窗口中提取相应的报文段重新发送。

##### 流量控制
##### 滑动窗口
##### 拥塞控制

如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。

拥塞控制主要是三个算法：1）慢启动，2）拥塞避免，3）快速恢复。

#### 三次握手

|  | 状态 | 标志位 SYN | 标志位 ACK | 内容 seq | 内容 ack |
|---|---|---|---|---|---|
| 第一次握手 客户端发起 | 客户端 SYN_SEND | 1 | - | x | - |
| 第二次握手 服务端发起 | 服务端 SYN_RCVD | 1 | 1 | y | x+1 |
| 第三次握手 客户端发起 | ESTABLISHED | - | 1 | - | y+1 |

#### 四次挥手

|  | 状态 | 标志位 FIN | 标志位 ACK | 内容 seq | 内容 ack |
|---|---|---|---|---|---|
| 第一次挥手 | | 1 | - | x | - |
| 第二次挥手 | | - | 1 | - | x+1 |
| 第三次挥手 | | 1 | - | y | - |
| 第四次挥手 | | - | 1 | - | y+1 |

最后会等待一个定长时间，没再收到消息就进入CLOSED状态；

#### SYN攻击

在连接过程中，出现大量不发送第三次握手的连接，使服务器存在大量半链接的session；服务端会不断的重试发送SYN包等待客户端确认，直至超时；

该攻击不能完全被阻止，规避方案

	* 缩短服务端超时时间
	* 增加最大半链接数
	* 过滤网关防护
	* SYN cookies技术

### HTTP特性

构建于TCP之上，是应用层的协议，默认端口号80；

短时间多次向服务器请求同一对象，服务端不会因为已经给客户端下发过该对象就不再作出反应，根据这种特性，我们称http为无状态协议；

#### 非持续链接 / 持续链接

持续请求、响应对是经一个单独的TCP链接发送，还是所有的请求及响应经相同的TCP链接发送，被称为非持续链接或持续链接；

`Connection: Keep-Alive`

在HTTP1.1以后都是默认持续连接的，以前的版本需要手动配置请求头；

#### http1.1

* 缓存处理
	* Entity tag
* 带宽优化及网络连接使用
	* 允许之请求资源的某个部分，断点续传
* 错误通知的管理
* host头处理
	* 在http1.0中认为每台服务器只有唯一的ip地址，没有传递主机名。但是后续发展为一台物理服务器上可以存在多个虚拟主机，共享一个ip地址。所以在1.1的请求消息和响应消息都支持host头域。
* 长连接
	* 1.1中支持长连接(PersistentConnection)和请求的流水线(Pipelining)处理，在一个TCP连接上可以传送多个HTTP请求和响应。

#### SPDY HTTP1.x的优化

2012年谷歌提出的方案，优化延时，提高安全性

* 降低延迟
	* 采取了多路复用(multiplexing)，通过多个请求stream共享一个TCP连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了贷款的利用率。
* 请求优先级
	* 解决多路复用之后关键请求被阻塞的问题。
* header压缩
* 强制HTTPS
* 服务端推送
	* 采用了SPDY的网页，服务器会主动推送资源文件给客户端，客户端就可以直接从缓存中读取，不用再发请求

#### HTTP2

算是SPDY的升级版

* 支持HTTP传输
* 改进header压缩算法

##### 2.0的多路复用和1.x的长连接复用的区别

* 1.x 一次请求-响应，建立一个连接，用完关闭，每个请求都要建立连接
* 1.1 Pipeling，若干个请求排队串行化单线程处理，后面前的请求等待前面的请求返回才能执行；一旦有请求超时后续请求就会被阻塞
* 2.0 多个请求可以同时在一个连接上并行执行；某个任务耗时严重也不会影响其他连接的正常执行

#### 会话跟踪

* 什么是会话

客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程，称之为会话；

* Cookie

Cookie是web服务器发送给客户端的一小段信息，客户端请求时可以读取该消息发送到服务器端，进而进行用户的识别；客户端的每次请求，服务器都会将Cookie发送到客户端，在客户端进行保存，以便下次使用；

Cookie可以保存在客户端内存中，称为临时Cookie，浏览器关闭后Cookie对象消失；另一种是保存在客户机的磁盘上，称为永久Cookie。

Cookie可以被客户端禁用；

* Session

每一个用户都有一个不同的session对象，不同用户之间不共享；

服务端会创建一个session对象，产生一个sessionId来标识这个session对象，然后将这个sessionId放到Cookie发送到客户端，用来识别不同的用户；

session的实现依赖cookie，cookie被禁用session也会失效；

### HTTPS

HTTPS 即 HTTP over TLS，是一种在加密信道进行http内容传输的协议；

	TLS的早期版本叫做SSL，但是基本已经被废弃。
	
TLS的【基本】过程如下

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8r3m9mqjsj30hw0fldhl.jpg)

0. 先完成TCP3次握手
1. 客户端发送`ClientHello`消息到服务端，包含TLS版本；
2. 服务端收到消息，向客户端发送`ServerHello`消息，消息包含服务端的TLS版本，公钥证书；其中证书中还包含了该证书所应用的域名范围，用于客户端验证身份；
3. 客户端根据内置的信任CA列表，验证服务端的证书是否可信；如果认为可信，会生成一串伪随机数，并使用服务器的公钥加密；这串随机数会被用于生成新的对称密钥；
4. 服务端使用自己的私钥解密得到上一步的随机数，然后使用这串随机数生成自己的对称主密钥；
5. 客户端发送一个`Finished`消息给服务端，并使用对称密钥加密这次通讯；
6. 服务器生成自己的hash值，解密客户端发来的信息，检查两个值是否对应；如果对应，就向客户端发送一个`Finished`消息，同样使用对称密钥加密；
7. 接下来整个TLS会话都使用对称密钥进行加密，传输HTTP的内容;

[完整详细流程](https://www.bilibili.com/read/cv1003093/)

#### 存在的风险及应对方案

中间人攻击

	引入HSTS技术，强制浏览器使用HTTPS访问网站；基本机制是在服务器返回的响应中，加上一个特殊的头部，指示浏览器对于此网站，强制使用HTTPS进行访问；
	
伪造证书攻击

攻击者挟持了DNS服务器，并且非法获得了合法证书；
	
	引入HPKP技术，在HSTS上更进一步，在返回头中储存公钥指纹信息，一旦发现指纹和接收到的公钥有差异，就认定正在被攻击；
	
### HTTP缓存

一般情况下客户端的缓存行为是由服务端控制的，分为`强缓存`和`协商缓存`。

#### 强缓存

* Pragma 【优先级高】【HTTP/1.0】
	* HTTP1.0 Pragma: no-cache
		* 响应头不支持这个属性
		* 为了兼容HTTP/1.0的客户端
		* 在HTTP/1.1中已被废弃
* Cache-Control 【优先级中】【HTTP/1.1】
	* no-cache 不直接使用缓存，根据新鲜度来使用缓存
	* no-store 不使用缓存，每次请求下载新资源
	* max-age:xx秒 缓存时长
	* public/private 是否只能被单个用户使用，默认为private
	* must-revalidate 每次访问需要缓存校验
		* 请求头和响应头都支持这个属性
		* 不适用于HTTP/1.0
		* 在缓存未失效前，获取不到修改后的资源
* Expire 【优先级低】【HTTP/1.0+】
	* GMT时间
		* 服务器和客户端时间不一致会有问题
		* 缓存未失效前，获取不到修改后的资源
		* 适用于HTTP/1.0和HTTP/1.1
	
![](https://tva1.sinaimg.cn/large/006tNbRwgy1gafqdgz5bjj30h20n6n7f.jpg)

#### 协商缓存

当第一次请求时，服务器返回的响应头中没有Cache-control和Expires，或者Cache-Control和Expires过期，或者属性设置为no-cache，那么浏览器第二次请求时就会与服务器进行协商，与服务器对比判断是否进行了修改。

协商缓存相关的头属性需要在请求头和响应头中成对出现，返回200状态码即由内容更新，返回304状态码则继续使用缓存数据。

* ETag/If-Not-Match 【优先级高】【HTTP/1.1】
	* 默认使用hash算法，在分布式环境下可能会出现不一致问题
	* 计算ETag需要性能消耗
	
* Last-Modified/If-Modified-Since 【优先级低】【HTTP/1.0】
	* 携带修改时间 GMT时间
		* 只要资源修改，不论内容是否有变化，都会全量返回
		* 某些服务器不能准确获取最后的修改时间

#### HTTP缓存的几个注意点

* 强缓存情况下，只要缓存还没过期，就会直接从缓存中取数据，无法获取到服务器修改后的数据；
	* 解决方案为，重新命名修改后的资源，避开本地缓存

* 尽量减少304的请求，从性能考虑尽量多使用强缓存

#### 浏览器缓存

常用的浏览器缓存有: cookie、sessionStorage、localStorage

### iOS中的HTTP缓存

#### NSURLCache

缓存原理: 每个`NSURLRequest`对应一个`NSCachedURLResponse`

缓存技术: 缓存的数据会在沙盒中以SQLite的方式保存

只对GET请求进行缓存，POST请求一般是发大量数据给服务器处理，变动性大；

疑似默认的响应头(NSHTTPURLResponse)中有参数 `Cache-Control: no-cache`，会持续保存缓存但是不使用。

#### NSURLRequestCachePolicy

`NSURLRequestCachePolicy`的描述

```
typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy) {
    NSURLRequestUseProtocolCachePolicy = 0,
    
    NSURLRequestReloadIgnoringLocalCacheData = 1,
    // 未实现
    NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4,
    NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData,

    NSURLRequestReturnCacheDataElseLoad = 2,
    NSURLRequestReturnCacheDataDontLoad = 3,
	// 未实现
    NSURLRequestReloadRevalidatingCacheData = 5, 
};
```

其中默认实现`NSURLRequestUseProtocolCachePolicy`代表按照协议的缓存策略执行，那么也就是可以理解其他的设置是独立于协议策略以外执行的。


如何使用`NSURLRequestCachePolicy`

```
NSURL *url;
NSMutableURLRequest *request;
request = [NSMutableURLRequest requestWithURL: url 
	cachePolicy: NSURLRequestUseProtocolCachePolicy 
	timeoutInterval: 30.0f];
```

