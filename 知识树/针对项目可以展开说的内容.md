## 项目点

### 有颜商城

* 网页加载加速
	* 排查网页耗时原因
		* 使用了js里面的`performance.timing`
	* 浏览器提前初始化，网页缓存
		* 创建wkwebview的对象复用池
	* 静态直出页面
		* 因为现在商城首页的内容还没有实现对不同用户的个性化推荐
	* 未实现，拦截请求
		* wkwebview通过私有api，可以实现
		* 离线包预推，增量更新
	* 复用客户端使用的域名和链接
	* 骨架屏
	
* vasSonic
	* 提前初始化webview
	* 客户端代理资源请求
		* 缓存数据，eTag标记缓存有效
			* eTag + IF-NOT-MATCH
	* 动态缓存、增量更新
	* h5页面动静分离
	* 预加载
	
* 试戴的模块设计
	* MVVM结构
		* Model - ViewModel - View/Controller
			* vm绑定model，计算出需要展示的数据，回传需要更新的内容
			* view绑定vm，view展示数据，接收用户操作，接口操作vm
	* 下载器
		* 下载队列，调度器
		* 素材的依赖下载内容

### 美颜相机、潮自拍

* 路由器 router
	* 目标: 模块解耦，实现页面自由跳转
	* 基于URL Scheme的跳转方案
		* 站内跳转 + openURL + Universal Links + Deeper Link
		* 站外跳转，需要注意来源验证
	* 问题: 没办法在参数中携带大文件，实现的话需要以 taget - action 形式改造
	
* swift的网络请求结构
	* moya + ObjectMapper
* 性能优化
	* 应用启动优化
		* sdk初始化 归于子线程
	* 包大小优化
		* 无用资源删除
		* .a 框架精简
			* armv7s arm64

### Whee Bee3D

* OC原生和Unity的交互
	* 通过自增id标记一次函数调用
	* 客户端调用Unity接口
		* iOS 声明 typedef void 函数指针A
		* Unity 声明 公共的静态类函数(public static extern)，可以全局访问
			* 在函数中传递 静态类函数(public static)的函数指针A
			* Unity在初始化时，调用声明好的公共静态类函数，调用iOS的接口，传递函数指针A
			* Unity可在这个函数A中用单例方式实现Unity的功能
		* 客户端通过单例保存获取到的指针A，就能通过调用函数指针调用Unity接口，声明的A为参数相同的格式
	* Unity调用客户端接口
		* Unity 声明 公共的静态类函数(public static extern)，可以全局访问
		* iOS 可以直接完成该函数接口实现

* 基于声网的视频推拉流
	* agora GPUImage



### 闪聊

* IM
	* TCP保活
		* 心跳包 4min30sec，50s超时
		* 在断线重连的判断中，需要先判断是否当前无网
		* 重连机制中，退避算法，每次增加随机时长，避免集中式访问
	* ACK APP层回执
		* TCP都只和服务器交互，由服务器保证消息剩余的消息收发完整
		* TCP的ACK只保证传输层面的消息送达，但是应用层需要自己的ack保证消息收到并完成处理
	* PB (protocol buffer)
		* 为什么小
			* Tag-Length-Value 算法，将数据转换为特殊的二进制流
				* 不需要分隔符，数据存储的很紧凑
				* 字段为空不加入编码，解码时设为默认值
				* varint(变长编码)，较小的字段分配较少的空间
		* 序列化、反序列化快
			* 编码方式简单，只有简单的数学运算、位运算
			* 采用自身的框架代码和编译器
			
	* 消息收发较多的情况下，发送成功的状态改变慢
		* 创建优先级不同的线程，分别处理发送回执、消息收取、其他的额外信令
	
	* TCP拥塞处理
		* 慢启动 指数上升
		* 拥塞避免 +1
		* 拥塞发生
		* 快速恢复
	
* DB操作频繁
	* 读写分离
		* 读操作使用FM自带的`FMDatabaseQueue`串行线程，同步任务
		* 写操作，异步线程OperationQueue，并发执行任务。包起FM的串行线程，同步任务

* 群会话头像
	* 检查前四位用户的头像地址，头像拼接之后保存在本地，本地位置写入数据库
	* 头像保存使用了SDImageCache<groupId: imageUrl>，本地文件保存群组前四位用户

* 会话列表
	* 列表的刷新太频繁
		* 利用`performSelector:afterDelay:`延后批量刷新，0.1刷新一次
	* 会话列表的卡顿
		* 未读数机制
			* 刷新列表时会从数据库中检索当前还未读的消息，记录未读数
			* 在缓存中维护
		* 将数据写入事务化
			* 原本每条消息都会单独处理DB，一条新消息会需要操作会话，用户信息等；
			* 事务处理操作，避免大量的数据库读写操作