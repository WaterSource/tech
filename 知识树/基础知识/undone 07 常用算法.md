## 常用算法

### 快速排序

在数组中选择基准值，其余的元素遍历和基准值比较大小，小的放在一侧，大的放在另一侧；然后对两个部分重复分区的操作，直到所有子元素区间不再需要执行上述步骤；

* 平均运行时间 最好运行时间 O(nlogn), 最坏运行时间O(n^2)
* 结果不稳定，存在相同元素交换位置的情况
* 最坏的情况
	* 数组本身有序，区分出来的两部分元素个数不平衡
		* 还原理解为，花了时间进行了比较操作，但是并没有完成实质的排序工作
	* 递归栈存在溢出风险
* 优化处理
	* 基准值的选择
		* 三数取中法，头中尾三数先比较大小，选中位放到最左侧
		* 随机选取基准
	* 优化小数组的交换，在长度小于10的情况可以选用插入排序
	* 聚合与基准相等的值

#### 插入排序

首位假设已排序，从第二位开始循环；对已排序队列逆序查找更小的值，将待排序值插入到后方；

*  平均运行时间 O(n^2)，最好 O(n)，最坏运行时间 O(n^2)

### 归并排序

将数组递归拆分成子数组，再循环根据元素大小合并两个子数组为次子数组；

* 运行时间: O(nlogn)，空间复杂度: O(n)
* 结果稳定
* 优化处理
	* 对小规模子数组使用插入排序
	* 二路归并前判断左侧最大，右侧最小，看是否能节约一次合并操作
	* 多线程实现递归部分，合并操作需要等待递归完成后执行

---

### 图或者树的搜索

* 有向图<u,v>和无向图(u,v)
* 权和网
	* 图的每条边上可能具有某种含义的数值，称为该边上的权；而带权的图被称为网
* 连通图和非连通图
	* 只针对无向图
	* 任意点都有路径可以连通与否

### BFS 广度优先搜索

类似树的层级遍历，需要有队列或者其他手段记录顶点已经被访问过(避免重复)，需要有栈来记录当前层级内容，用于下一层遍历；


### DFS 深度优先搜索

类似树的先序遍历(根左右)，同样需要有队列或者其他手段记录已经被访问过的顶点(避免重复)，递归栈记录剩余的分支路径；

