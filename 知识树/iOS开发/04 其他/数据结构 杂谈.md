## 数据结构 杂谈

### 什么是Hash

一种将任意长度的消息压缩到某一固定长度的消息摘要的函数；

关键词: 任意长度，固定长度，压缩

#### MD5 SHA-1

应用场景: 文件校验，数字签名，鉴权协议

MD5输出的长度为128bit；

SHA-1输出的长度为160bit；

### 海量数据查找算法

应用场景: 搜索引擎中URL过滤，避免重复记录形成环

1. 数据库sql查询
2. HashSet查询
3. URL经过MD5或SHA-1等单向hash后在保存到HashSet或数据库
4. BitMap，建立一个bitset，将每个URL经过hash函数映射到某一位
5. 布隆过滤器

方法1-3都能将访问过的URL完整保存，4、5则转换为记录标志位；

数据量增大后会出现一些问题。

* 方法1，关系型数据库的查询效率很低，每次查询都启用数据库查询小题大做
* 方法2，太消耗内存。随着URL的数量上升，占用的内存会越来越大。假设1亿个URL，每个URL50bit，就需要5GB内存
* 方法3，是方法2的优化方案
* 方法4，消耗内存相对较小，缺点是单一Hash函数发生冲突的概率太高。若要降低冲突发生的概率到1%，那么就要将BitSet的长度设置为URL个数的100倍。

#### 布隆过滤器

使用场景: 海量文本中查找某个词语

由一个很长的二进制向量及多个随机函数组成，加入元素时，利用N个哈希方法将元素映射为N个点，N个点组成一个位阵列形式，且他们的值设定为1。当需要判断是否存在时(即查找)，判断新产生的位阵列是否均为1即可，然后可按照`&`与运算进行。

输出为0，可以判定一定不存在；输出为1，可以判断元素存在。但是存在误算率，误算率会随着存入的元素数量增加而增加；但是如果元素数量太少，使用散列表即可。

布隆过滤器也存在一些问题，不支持删除，以及存在的概率性上；

	举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。
	
#### Hashing

适用范围，快速查找，删除的基本数据结构，通常需要总数据量可以放入内存。

重点在于发生冲突的处理方案上；

* 开放地址法，在首次的结果上通过一些方法再次定位
	* 线性探测再散列，在首次的序列后开始遍历查找空位
	* 二次探测再散列，通过左右跳跃式探测查找空位
	* 伪随机探测再散列，通过随机数查找空位
* 再hash法
* 拉链法、链地址法，将同结果的元素构成链表，适用于经常插入和删除的情况
	* 存在链表长度过大，需要扩容hashmap的场景
* 建立公共溢出区，将发生冲突的元素单独存放

---

### 数据库

sql本身是关系型数据库，索引是一个B+树结构；

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaiccar59nj30sc0ajwgn.jpg)

#### disk的I/O瓶颈

因为内存(Memory)和磁盘(Disk)相比虽然读取速度快，但是价格也更贵，所以空间普遍比disk小；

所以大尺寸的数据都只能存在disk上，用的时候才读取到内存，没操作一次就是一次磁盘的I/O操作；而数据库其实也是一个大文件，每次sql查询的时候就是去读文件，而且一次查询往往需要多次I/O才能完成；

#### 事务 (Transaction)

正常加入数据的过程是: 开始新事务 -> 插入数据 -> 提交事务；

那么往表内插入500条数据，按照常规操作就是执行500次开始+提交的过程;

那么主动使用事务进行批量提交，就能优化数据库的写入性能；